import 
  _Int_
  _Float_
  _Char_
  _String_
  _Uint_
  _Array_
in module Prelude {
  Array ..,
  Int, Uint, Char, String, Bool, Float,
} where

Int = _Int_
Float = _Float_
Char = _Char_
String = _String_
Uint = _Uint_
Bool = True | False

-*@Doc 
 * Array: an (@Code n)-element sequence of type (@Code a)
**-
[a; n: Uint] =
  [_]: [a; 0]
  | (_::_) a [a; n]: [a; n+1]


-*@Doc
* Ret
*-
(if _ then _ else _): Bool -> a -> a -> a
(if _ then _ else _) c t f = 
  match c in
    True -> t
    False -> f


(_ && _): Bool -> Bool -> Bool
a && b = if a then b else False

(_ || _): Bool -> Bool -> Bool
a || b = if a then True else b

! : Bool -> Bool
! a = if a then False else True

-- ignores result of first argument;
-- this is useful for forcing an expression to evaluate
-- without needing to use the value of it
(_; _): a -> b -> b
_; f = f

-- let captures all things on the next tokens indentation line
let
x = 3
y = 5

-- also okay
let
  x = 3
  y = 5

-- also okay
  let
x = 3
y = 4

-- okay, continue based on token following 'in'
let x = 3 in
let x = 4 ..

-- okay, continue based on token following 'in'
match x in 
  Thing -> ..

-- okay, continue based on token following 'match'
match
x ..

module main
where