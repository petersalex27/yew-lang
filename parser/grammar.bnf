# TODO: new
SHIFT         ::= _ @ INDENT(_)
# NOTE: what is this doing?
#   - because SHIFT always happens when there is an INDENT in lookahead (L.A.)
#     position, this happens once the next L.A. is not an IDENT. 
#     - so, this is effectively just taking the last INDENT token
INDENT(n)     ::= INDENT(_) INDENT(n)
indent(n)     ::= ( '=' ) INDENT(n)
                  | ( 'where' ) INDENT(n) 
                  | ( 'let' ) INDENT(n) 
                  | ( 'in' ) INDENT(n)
                  | ( 'of' ) INDENT(n)
                  | ( 'match' ) INDENT(n)
# this only happens when the next token is not an indent token
indent(0)     ::= ( '=' ) 
                  | ( 'where' ) 
                  | ( 'let' ) 
                  | ( 'in' ) 
                  | ( 'of' ) 
                  | ( 'match' )
moduleHead    ::= 'module' ID
exportDone    ::= export ')'
exportHead    ::= moduleHead '('
                  | export ','
                  | export TYPE_ID ','
                  | export TYPE_ID '..' ','
export        ::= exportHead ID
                  | exportHead SYMBOL
                  | exportHead INFIXED
module        ::= moduleHead
                  | exportDone
source        ::= module 'where' indent(n) definitions
                  | module
# TODO: updated
trait         ::= traitDecl 'where' indent(n) functionDefs
definitions   ::= ( INDENT(n) ) functions INDENT(n) definitions
                  | ( INDENT(n) ) functionDefs INDENT(n) definitions
                  | ( indent(n) ) functions INDENT(n) definitions
                  | ( indent(n) ) functionDefs INDENT(n) definitions
                  | ( INDENT(n) ) functions
                  | ( INDENT(n) ) functionDefs
                  | ( indent(n) ) functions
                  | ( indent(n) ) functionDefs
literal       ::= INT_VALUE 
                  | CHAR_VALUE 
                  | STRING_VALUE 
                  | FLOAT_VALUE
                  | literalArray
val           ::= literal
                  | array
arrayValHead  ::= '[' expr
                  | arrayValHead ',' expr
                  | litArrHead ',' expr
array         ::= arrayValHead ',' ']'
                  | arrayValHead ']'
litArrHead    ::= '[' literal
                  | litArrHead ',' literal
literalArray  ::= literalArray ',' ']'
                  | literalArray ']'
name          ::= ID
                  | TYPE_ID
funcName      ::= SYMBOL 
                  | INFIXED
                  | ID
param         ::= ID
                  | THUNKED
# TODO: updated
constructor   ::= TYPE_ID
                  | typeDecl
                  | constructor name
                  | constructor constructor
                  | '(' constructor ')'
                  | ( '(' ) constructor INDENT(_)
application   ::= expr expr
# TODO: updated
expr          ::= val
                  | data
                  | funcName
                  | letExpr
                  | application
                  | pattern
                  | whereExpr
                  | judgement
                  | '(' expr ')'
                  | ( '(' ) expr INDENT(_)
# TODO: comp. changed grammar for production
patternMatch  ::= 'match' indent(n) expr 'in' indent(m) case
# TODO: comp. changed grammar for production
case          ::= ( indent(n) ) data '->' expr
                  | ( indent(n) ) case INDENT(n) data '->' expr
# TODO: changed from function to function***s***
letExpr       ::= 'let' indent(n) functions 'in' indent(m) expr
# TODO: changed from function to function***s***
whereExpr     ::= expr 'where' indent(n) functions
# TODO: updated
pattern       ::= constructor
                  | literal
                  | funcName
                  | pattern pattern
									| '(' pattern ')'
                  | ( '(' ) pattern INDENT(_)
data          ::= pattern
                  | data expr
                  | '(' data ')'
                  | ( '(' ) data INDENT(_)
judgement     ::= expr ':' type
                  | '(' judgement ')'
functionDecl  ::= funcName
functionHead  ::= functionDecl pattern
                  | functionDecl @ '=' | ':'               # only when L.A. is '=' or ':'
functionDef   ::= functionHead ':' type
									| functionHead @ '='
functionDefs  ::= ( INDENT(n) ) functionDef INDENT(n) functionDefs
                  | ( INDENT(n) ) functionDef
                  | ( indent(n) ) functionDef INDENT(n) functionDefs
                  | ( indent(n) ) functionDef
function      ::= functionDef '=' indent(n) expr
# think about this as making an expression composed of a sequence of functions
functions     ::= ( INDENT(n) ) function INDENT(n) functions
                  | ( INDENT(n) ) function
                  | ( indent(n) ) function INDENT(n) functions
                  | ( indent(n) ) function
typeDecl      ::= TYPE_ID
                  | typeDecl ID
# TODO: new
typeDef       ::= typeDecl '=' indent(n) constructor
                  | typeDef '|' constructor
type          ::= polytype 
                  | monotype 
                  | dependent
                  | '(' type ')'
polyHead      ::= 'forall' ID
                  | polyHead ID
polyBinders   ::= polyHead @ '.'                       # when l.a. is '.'
                  | '(' polyBinders ')' @ '.'          #   //
polytype      ::= polyBinders '.' dependentTyped
dependentHead ::= 'mapall' varJudgement
                  | dependentHead varJudgement
dependBinders ::= dependentHead @ '.'                  # when l.a. is '.'
                  | '(' dependBinders ')' @ '.'         #   //
dependent     ::= dependBinders '.' monotype
dependInst    ::= arrayHead ']'
arrayHead     ::= '[' monotype
                  | '[' monotype ';' expr
appType       ::= monotype monotype
                  | namedApp
monotype      ::= monotype '->' monotype
                 | '(' monotype ')'
                 | TYPE_ID
                 | monotype monotype
                 | '(' monotype tupleType
tupleType     ::= ',' monotype ')'
                 | ',' monotype tupleType
varJudgement  ::= ID ':' monotype
                  | '(' varJudgement ')'
