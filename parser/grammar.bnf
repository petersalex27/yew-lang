literal       ::= INT_VALUE 
                  | CHAR_VALUE 
                  | STRING_VALUE 
                  | FLOAT_VALUE
                  | literalArray
val           ::= literal
                  | array
arrayValHead  ::= '[' expr
                  | arrayValHead ',' expr
                  | litArrHead ',' expr
array         ::= arrayValHead ',' ']'
                  | arrayValHead ']'
litArrHead    ::= '[' literal
                  | litArrHead ',' literal
literalArray  ::= literalArray ',' ']'
                  | literalArray ']'
name          ::= ID
                  | TYPE_ID
funcName      ::= SYMBOL 
                  | INFIXED
                  | ID
param         ::= ID
                  | THUNKED
constructor   ::= TYPE_ID
                  | typeDecl
                  | constructor name
                  | constructor constructor
                  | '(' constructor ')'
expr          ::= val
                  | data
                  | funcName
                  | letIn
                  | application
                  | pattern
                  | exprWhere
                  | judgement
                  | '(' expr ')'
application   ::= expr expr
patternMatch  ::= expr 'when' case
case          ::= case data '->' expr
                  | data '->' expr
letIn         ::= 'let' function 'in' expr
exprWhere     ::= expr 'where' function
pattern       ::= constructor
                  | literal
                  | funcName
                  | pattern pattern
									| '(' pattern ')'
data          ::= pattern
                  | data expr
                  | '(' data ')'
judgement     ::= expr ':' type
                  | '(' judgement ')'
functionDecl  ::= INDENT funcName
functionHead  ::= functionDecl pattern
                  | functionDecl                # only when L.A. is '=' or ':'
functionDef   ::= functionHead ':' type
									| functionHead      					# only when L.A. is '='
function      ::= functionDef '=' expr
typeDecl      ::= TYPE_ID
                  | typeDecl ID
typeDef       ::= typeDecl '=' constructor
                  | typeDef '|' constructor
type          ::= polytype 
                  | monotype 
                  | dependent
                  | '(' type ')'
polyHead      ::= 'forall' Id
                  | polyHead Id
polyBinders   ::= polyHead                        # when l.a. is '.'
                  | '(' polyBinders ')'           #   //
polytype      ::= polyBinders '.' dependentTyped
dependentHead ::= 'mapall' varJudgement
                  | dependentHead varJudgement
dependBinders ::= dependentHead                   # when l.a. is '.'
                  | '(' dependBinders ')'         #   //
dependent     ::= dependBinders '.' monotype
dependInst    ::= arrayHead ']'
arrayHead     ::= '[' monotype
                  | '[' monotype ';' expr
appType       ::= monotype monotype
                  | namedApp
monotype      ::=
varJudgement  ::= ID ':' monotype
                  | '(' varJudgement ')'
