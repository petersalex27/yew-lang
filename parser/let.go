package parser

import (
	"strconv"

	"github.com/petersalex27/yew-lang/token"
	"github.com/petersalex27/yew-packages/expr"
	"github.com/petersalex27/yew-packages/parser"
	"github.com/petersalex27/yew-packages/parser/ast"
)

// letExpr ::= 'let' function 'in' expr

var letExpr__Let_function_In_expr_r = parser.
	Get(letReduction).From(Let, Function, In, Expr)

// convers a sequence of expression into an application by applying the 
// expressions left-to-right
func toApplication[T expr.Expression[token.Token]](params []T) expr.Expression[token.Token] {
	if len(params) == 0 {
		return nil
	}

	var out expr.Expression[token.Token] = params[0]
	for _, ex := range params[1:] {
		out = expr.Apply[token.Token](out, ex)
	}
	return out
}

// letExpr <- 'let' function 'in' expr
func letReduction(nodes ...ast.Ast) ast.Ast {
	const _, functionIndex, _, exprIndex int = 0, 1, 2, 3

	function := nodes[functionIndex].(FunctionNode)
	expression := nodes[exprIndex].(ExpressionNode).Expression

	/*== break apart function into component parts ============================*/
	nameToken := function.def.head.name
	name := Const(nameToken) // appears as `name` in comments
	// pattern representing the params
	params := function.def.head.params // appears as `a0 a1 ..` in comments
	numParams := len(params)
	body := function.body // appears as `body` in comments

	// let expression that will be put inside a let expression node
	var letExpr expr.NameContext[token.Token]

	// two cases for input = `let function in expression`:
	// 	(1) function has the form `name = body`
	// 	(2) function has the form `name a0 a1 .. = body`

	if numParams == 0 {
		/*== case (1) ===========================================================*/
		letExpr = expr.Let(name, body, expression)
	} else { 
		/*== case (2) ===========================================================*/
		// need to convert function into a form that can be used with the name
		// context expression and function expression. There are two challenges to
		// this:
		//	(1) function nodes allow complex patterns for parameters, but function
		//			expressions only allow variables (binders, actually)
		//	(2) function nodes are named but function expressions are anon.
		// - The second challenge is easy to overcome under the assumption that the 
		//   function node only has a single linear sequence of variables for 
		//	 params. Call this form of function nodes "perfect function node".
		// - The first challenge can be overcome by translating the function node
		// 	 into a case of a `selection` expression where the LHS is the params 
		//	 pattern and the RHS is the function body. Then the function node can
		//	 safely lose the pattern information and be generalized into a 
		//	 "perfect function node" that abstracts the `selection` expression

		// Selection expressions have hidden binders used to bind things inside
		// "patterns". For now, this can be empty
		emptyBinders := expr.Bind[token.Token]()

		/*== create the parts needed for a "perfect function" ===================*/
		// binders that generalize the function param-pattern
		binders := make([]expr.Variable[token.Token], numParams)
		for i := range binders {
			// - to avoid capturing, binders, i.e., variables, must not be free in 
			//   the function body.
			// - variables in the source code can never contain "$p", and the only
			//	 way they can appear is as bound variables or binders generated by
			//	 the compiler
			// - thus, any variable prefixed with "$p" will not be free in the 
			//	 function body
			paramStr := parameterStringPrefix + strconv.Itoa(i)
			paramToken := token.Id.Make().AddValue(paramStr)
			paramVar := expr.Var(paramToken)
			binders[i] = paramVar
		}

		// convert the function node into a single case statement using the pattern
		// as the LHS and body as the RHS
		//		a0 a1 .. -> body
		case_ := emptyBinders.InCase(toApplication(params), body)
		// create the selection statement that serves as the body of the new, 
		// general anon. function
		//		($p0 $p1 ..) when ((a0 a1 ..) -> body)
		patternMatch := expr.Select(toApplication(binders), case_) 
		// create the anon. function that generalizes the "imperfect" function 
		//		(\$p0 $p1 .. -> ($p0 $p1 ..) when ((a0 a1 ..) -> body))
		anon := expr.Bind[token.Token](binders...).In(patternMatch)
		// in full:
		//		let name = (\$p0 $p1 .. ->
		//			($p0 $p1 ..) when
		//				(a0 a1 ..) -> body)
		letExpr = expr.Let[token.Token](name, anon, expression)
	}

	return SomeExpression{LetExpr, letExpr}
}
